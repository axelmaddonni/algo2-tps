\begin{Interfaz}

  \textbf{usa}: \tadNombre{tupla,  nat, bool, $\alpha$}.
  
  \textbf{se explica con}: \tadNombre{Cola de Prioridad Alternativa}.

  \textbf{g\'eneros}: \TipoVariable{colaLog($\alpha$)}.

  \Titulos{Operaciones de Cola de Prioridad $_{HEAP}$}

  \InterfazFuncion{Vacia}{}{colaLog($\alpha$)}
  {res =$_{obs}$ vacia}%
  [$O(1)$]
  [Crea una cola vacia.]
  []

  \InterfazFuncion{Vacia?}{\In{estr}{colaLog($\alpha$)}}{bool}
  {$res$ =$_{obs}$ vacia?($estr$)}%
  [$O(1)$]
  [Indica si la cola esta vacia.]
  []

  \InterfazFuncion{Pr\'oximo}{\In{estr}{colaLog($\alpha$)}}{tupla($nat, \alpha$)}
  [$\neg Vacia?(estr)$]
  {$res =_{obs} proximo(estr)$}%
  [$O(copiar(\alpha))$]
  [Devuelve una tupla que contiene al pr\'oximo elemento y su prioridad.]
  

  \InterfazFuncion{Encolar}{\Inout{estr}{colaLog($\alpha$)}, \In{prio}{nat}, \In{valor}{$\alpha$}}{bool} %res no me sirve para nada...lo puedo sacar o siempre tiene que estar aunque lo ponga siempre en true?
  [estr = estr$_0$]
  {$res$ $\wedge$ estr =$_{obs}$ encolar(estr$_0$)}%
  [$O(log(n) + copiar(\alpha))$]
  [Crea un nuevo elemento con los parametros dados y lo agrega a la cola.]
  []

  \InterfazFuncion{Desencolar}{\Inout{estr}{colaLog($\alpha$)}}{$\alpha$}
  [estr = $estr_0 \ \wedge \neg Vacia?(estr)$] 
  {estr =$_{obs}$ desencolar($estr_0$) $\wedge \ res =_{obs} proximo(estr_0)$}%
  [$O(log(n) + copiar(\alpha) + borrar(\alpha))$]
  [Devuelve al elemento de mayor prioridad y lo remueve de la cola. La cola no debe estar vac\'ia.]
  []
  
  
\end{Interfaz}

\newpage

\begin{tad}{\tadNombre{Cola de prioridad alternativa($\alpha$)}}
\tadGeneros{colaPrio($\alpha$)}
\tadExporta{colaPrio($\alpha$), generadores, observadores}
\tadUsa{\tadNombre{Bool, Nat, Tupla}}

\tadAlinearFunciones{desencolar}{nat,$\alpha$,colaPrior($\alpha$)}

\tadObservadores
\tadOperacion{vac\'ia?}{colaPrior($\alpha$)}{bool}{}
\tadOperacion{pr\'oximo}{colaPrior($\alpha$)/c}{tupla($nat, \alpha$)}{$\neg$ vac\'ia?($c$)}
\tadOperacion{desencolar}{colaPrior($\alpha$)/c}{colaPrior($\alpha$)}{$\neg$ vac\'ia?($c$)}

\tadGeneradores
\tadOperacion{vac\'ia}{}{colaPrior($\alpha$)}{}
\tadOperacion{encolar}{nat,$\alpha$,colaPrior($\alpha$)}{colaPrior($\alpha$)}{}

\tadAxiomas[\paratodo{colaPrior($\alpha$)}{c}, \paratodo{$\alpha$}{e}]
\tadAlinearAxiomas{desencolar(encolar($p$, $e$, $c$))}{}

\tadAxioma{vac\'ia?(vac\'ia)}{true}
\tadAxioma{vac\'ia?(encolar($p$, $e$, $c$))}{false}

\tadAxioma{pr\'oximo(encolar($p$, $e$, $c$))}{\textbf{if} vac\'ia?($c$) $\oluego$\ $\Pi_1(proximo(c)) < p$ \textbf{then} $<p,e>$ \textbf{else} \textbf{if} $\Pi_1(proximo(c)) = p$ \textbf{then} $<p,e>  \vee \ proximo(c)$ \textbf{else} $proximo(c)$ \textbf{fi} \textbf{fi}}
\tadAxioma{desencolar(encolar($p$, $e$, $c$))}{\textbf{if} vac\'ia?($c$) $\oluego$\ $\Pi_1(proximo(c)) < p$ \textbf{then} $c$ \textbf{else} \textbf{if} $\Pi_1(proximo(c)) = p$ \textbf{then} $c\  \vee \ encolar(p, e, desencolar(c)$ \textbf{else}  $encolar(p, e, desencolar(c)$ \textbf{fi} \textbf{fi}}

\end{tad}

\newpage

\begin{Representacion}

\begin{Estructura}{colaLog($\alpha$)}[estr\_heap($\alpha$)]

\begin{Tupla}[estr\_heap($\alpha$)]
	\tupItem{size}{nat} \newline \nomoreitems
	\tupItem{primero}{nodo($\alpha$)} \newline \nomoreitems
\end{Tupla}

\begin{Tupla}[nodo($\alpha$)]
	\tupItem{padre}{puntero(nodo($\alpha$))} \newline \nomoreitems
	\tupItem{izq}{puntero(nodo($\alpha$))} \newline \nomoreitems
	\tupItem{der}{puntero(nodo($\alpha$))} \newline \nomoreitems
	\tupItem{prio}{nat} \newline \nomoreitems
	\tupItem{valor}{$\alpha$} \newline \nomoreitems
\end{Tupla} 

\end{Estructura}

Rep: estr\_heap($\alpha$) $\rightarrow$ bool
\newline \indent Rep($estr$) $\equiv$ true $\iff \ size = \# arbol(estr.primero) \ \wedge_L
\newline \indent ((estr.primero).padre = null \wedge
\newline \indent (\forall n: nodo(\alpha))( n \in arbol(estr.primero) \wedge \ n \neq estr.primero \Rightarrow (n.padre \neq null \wedge_L (((n.padre).izq = n \vee (n.padre).der = n ) \wedge \
\neg(((n.padre).izq = n \wedge (n.padre).der = n ))))) \wedge
\newline \indent (\forall n: nodo(\alpha))( n \in arbol(estr.primero) \Rightarrow ((n.izq \neq null \Rightarrow n.prio \geq (n.izq).prio) \wedge (n.der \neq null \Rightarrow n.prio \geq (n.der).prio))) \wedge
\newline \indent (\forall n: nodo(\alpha))( n \in arbol(estr.primero) \Rightarrow caminoHastaRaiz(n,arbol(estr.primero)) \leq \left \lfloor{log_2(size)}\right \rfloor + 1))$

\textbf{}
\textbf{}

Abs: estr\_heap($\alpha$) $e \rightarrow$ colaPrio($\alpha$) \{ Rep($e$) \} \newline
Abs($e$) $\equiv$ c: colaPrio($\alpha$) | $(Vacia?(c) \iff e.primero == NULO) \wedge_L
\newline \indent (\neg Vacia?(c) \Rightarrow Proximo(c) = *(estr.primero)) \ \wedge
\newline \indent (\neg Vacia?(e) \Rightarrow Desencolar(e) = Desencolar(c))$

\textbf{}
\textbf{}

\textbf{Especificaci\'on de las operaciones auxiliares utilizadas para Rep y Abs}
\tadOperacion{arbol}{nodo($\alpha$)}{conj(nodo($\alpha$))}{}
\tadOperacion{caminoHastaRaiz}{nodo($\alpha$)}{nat}{}
\tadAxioma{arbol(n)}{
\IF {$n.izq \neq null \wedge n.der \neq null$}
THEN {Ag($n,arbol(n.izq)\cup arbol(n.der)$)}
ELSE { \IF {$n.izq \neq null$}
		THEN {Ag($n,arbol(n.izq)$)}
		ELSE { \LIF\ $n.der \neq null$ \LTHEN\ Ag($n,arbol(n.der)$) \LELSE\ Ag($n,\emptyset$) \LFI}
		FI}
FI}

\tadAxioma{caminoHastaRaiz(n)}{\textbf{if} $n.padre = null$ \textbf{then} $0$ \textbf{else} $caminoHastaRaiz(n.padre)+1$ \textbf{fi}}
		
%\textbf{if} $n.izq \neq null \wedge n.der \neq null$ \textbf{then} Ag($n.valor,arbol(n.izq)\cup arbol(n.der)$) \textbf{else}
%\textbf{if} $n.izq \neq null$ \textbf{then} Ag($n.valor,arbol(n.izq)$) \textbf{else} \textbf{if} $n.der \neq null$ \textbf{then} Ag($n.valor,arbol(n.der)$) \textbf{else} Ag($n.valor,\emptyset$)}


\end{Representacion}

\newpage

\begin{Algoritmos}

\begin{algorithm}
\caption{Implementaci\'on de Vacia}
\begin{algorithmic}[0]
\Function{iVacia}{}{$\rightarrow res$: colaLog($\alpha$)}
\State $res\gets $ <$0, null$> \Comment{O(1)}
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Implementaci\'on de Vacia?}
\begin{algorithmic}[0]
\Function{iVacia?}{\In{estr}{estr\_heap($\alpha$)}}{$\rightarrow res$: bool}
\State $res\gets \ (estr.primero == null)$ \Comment{O(1)}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Implementaci\'on de Pr\'oximo}
\begin{algorithmic}[0]
\Function{Pr\'oximo}{\In{estr}{estr\_heap($\alpha$)}}{$\rightarrow res$: tupla($nat, \alpha$)}
\State $res\gets \ <(estr.primero).prioridad, (estr.primero).valor>$ \Comment{O(copiar($\alpha$))}
\EndFunction
\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\caption{Implementaci\'on de Encolar}
\begin{algorithmic}[0]
\Function{iEncolar}{\Inout{estr}{estr\_heap($\alpha$)}, \In{prio}{nat}, \In{valor}{$\alpha$}}{$\rightarrow res$: bool}
	\State $res\gets $ $true$	 \Comment{O(1)}
	\If{estr.size == 0} \Comment{O(1)}
		\State $estr.primero\gets$ puntero(<$null, null, null, prio, valor$>) \Comment{O(copiar($\alpha$))}
	\Else
		\State $size++$ \Comment{O(1)}
		\State $x\gets \ sizer$ \Comment{O(1)}
		\State $y\gets$ <> \Comment{O(1)}
		\While{x $\neq$ 0} \Comment{La cantidad de veces que se ejecuta el ciclo es igual a la altura del heap. Al ser un arbol binario completo, la altura siempre ser\'a O(log(n))}
			\State $y\gets$ $(x \% 2) \bullet y$ \Comment{O(1)}
			\State $x\gets$ $x / 2$ \Comment{O(1)}
		\EndWhile
		\State $y\gets$ com($y$) \Comment{O(log(n))}
		\State $z\gets$ $estr.primero$ \Comment{O(1)}
		\State $y\gets$ fin($y$) \Comment{O(1)}
		\While{long($y$)$>1$} \Comment{El ciclo se ejecuta O(log(n)) veces}
			\State $z\gets$ \textbf{if} prim($y$) $==$ 0 \textbf{then} $z.izq$ \textbf{else} $z.der$ \Comment{O(1)}
			\State $y\gets$ fin($y$) \Comment{O(1)}
		\EndWhile
		\State $w\gets$ <$null,null,null,prio,valor$> \Comment{O(copiar($\alpha$))}
		\State $w.padre\gets$ $z$ \Comment{O(1)}
		\If{prim($y$) $==$ 0} \Comment{O(1)}
			\State $z.izq\gets \ w$ \Comment{O(1)}
		\Else
			\State $z.der\gets \ w$ \Comment{O(1)}
		\EndIf
		\While{w $\neq \ estr.primero \ \wedge_L \ w.prio > (w.padre).prio$} \Comment{La cantidad de veces que se ejecuta el ciclo es a lo sumo la altura del heap, que es O(log(n))}
			\State $aux\gets \ w.valor$ \Comment{O(copiar($\alpha$))}
			\State $w.valor\gets \ (w.padre).valor$ \Comment{O(copiar($\alpha$))}
			\State $(w.padre).valor\gets \ aux$ \Comment{O(copiar($\alpha$))}
			\State $aux2\gets \ w.prio$ \Comment{O(1)}
			\State $w.prio\gets \ (w.padre).prio$ \Comment{O(1)}
			\State $(w.padre).prio\gets \ aux2$ \Comment{O(1)}
			\State $w\gets \ w.padre$ \Comment{O(1)}
		\EndWhile
	\EndIf

\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Implementaci\'on de Desencolar}
\begin{algorithmic}[0]
\Function{iDesencolar}{\Inout{estr}{estr\_heap($\alpha$)}}{$\rightarrow res$: $\alpha$}
	\State $res\gets \ *(estr.primero)$ \Comment{O(1)}
	\State $x\gets \ size$ \Comment{O(1)}
	\State $y\gets \ $ <> \Comment{O(1)}
	\While{x $\neq$ 0} \Comment{La cantidad de veces que se ejecuta el ciclo es igual a la altura del heap. Al ser un arbol binario completo, la altura siempre ser\'a O(log(n))}
		\State $y\gets$ $(x \% 2) \bullet y$ \Comment{O(1)}
		\State $x\gets$ $x / 2$ \Comment{O(1)}
	\EndWhile
	\State $y\gets$ com($y$) \Comment{O(log(n))}
	\State $z\gets$ $estr.primero$ \Comment{O(1)}
	\State $y\gets$ fin($y$) \Comment{O(1)}
	\While{long($y$)$>1$} \Comment{El ciclo se ejecuta O(log(n)) veces}
		\State $z\gets$ \textbf{if} prim($y$) $==$ 0 \textbf{then} $z.izq$ \textbf{else} $z.der$ \Comment{O(1)}
		\State $y\gets$ fin($y$) \Comment{O(1)}
	\EndWhile
	\State $w\gets$ <$null,null,null,prio,valor$> \Comment{O(copiar($\alpha$))}
	\State $w.padre\gets$ $z$ \Comment{O(1)}
	\If{prim($y$) $==$ 0} \Comment{O(1)}
		\State $z.izq\gets \ puntero(w)$ \Comment{O(1)}
	\Else
		\State $z.der\gets \ puntero(w)$ \Comment{O(1)}
	\EndIf
	\State $(estr.primero).valor\gets \ z.valor$ \Comment{O(copiar($\alpha$))}
	\State $(estr.primero).prio\gets\ z.prio$ \Comment{O(1)}
	\State borrar($z$) \Comment{O(borrar($\alpha$))}
	\State $z\gets\ estr.primero$ \Comment{O(1)}
	\State $size--$ \Comment{O(1)}
	\While{$(z.izq \neq null \ \vee z.der \neq null) \ \wedge_L \ z.prio < \ maxPrio(z.izq, z.der)$} \Comment{La cantidad de veces que se ejecuta el ciclo es a lo sumo la altura del heap, que es O(log(n))}

	\State \comentario{maxPrio devuelve la maxima prioridad si ambos punteros son validos, o la prioridad apuntada por
	el puntero no nulo en caso de que alguno no lo sea}
	\If{$z.der == null \ \vee_L \ (z.izq).prio \geq (z.der).prio$} \Comment{O(1)}
		\State $aux\gets \ z.valor$ \Comment{O(copiar($\alpha$))}
		\State $z.valor\gets \ (z.izq).valor$ \Comment{O(copiar($\alpha$))}
		\State $(z.izq).valor\gets \ aux$ \Comment{O(copiar($\alpha$))}
		\State $aux2\gets \ z.prio$ \Comment{O(1)}
		\State $z.prio\gets \ (z.izq).prio$ \Comment{O(1)}
		\State $(z.izq).prio\gets \ aux2$ \Comment{O(1)}
		\State $z\gets z.izq$ \Comment{O(1)}
	\Else
		\State $aux\gets \ z.valor$ \Comment{O(copiar($\alpha$))}
		\State $z.valor\gets \ (z.der).valor$ \Comment{O(copiar($\alpha$))}
		\State $(z.der).valor\gets \ aux$ \Comment{O(copiar($\alpha$))}
		\State $aux2\gets \ z.prio$ \Comment{O(1)}
		\State $z.prio\gets \ (z.der).prio$ \Comment{O(1)}
		\State $(z.der).prio\gets \ aux2$ \Comment{O(1)}
		\State $z\gets z.der$ \Comment{O(1)}
	\EndIf
	\EndWhile


\EndFunction
\end{algorithmic}
\end{algorithm}

\FloatBarrier
\end{Algoritmos}


