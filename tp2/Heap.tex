\begin{Interfaz}

  \textbf{usa}: \tadNombre{tupla,  nat, bool, $\alpha$}.
  
  \textbf{se explica con}: \tadNombre{Cola de Prioridad Alternativa}.

  \textbf{g\'eneros}: \TipoVariable{heap}.

  \Titulos{Operaciones de Cola de Prioridad $_{HEAP}$}

  \InterfazFuncion{Vacia}{}{heap}
  {res =$_{obs}$ vacia}%
  [O(1)]
  [Crea una cola vacia.]
  []

  \InterfazFuncion{Vacia?}{\In{estr}{heap}}{bool}
  {$res$ =$_{obs}$ vacia?($estr$)}%
  [O(1)]
  [Indica si la cola esta vacia.]
  []

  \InterfazFuncion{Primero}{\In{estr}{heap}}{tupla($nat, \alpha$)}
  [$\neg Vacia?(estr)$]
  {$res =_{obs} primero(estr)$}%
  [O(1)]
  [Devuelve una tupla que contiene al primer elemento y su prioridad.]
  

  \InterfazFuncion{Encolar}{\Inout{estr}{heap}, \In{prio}{nat}, \In{valor}{$\alpha$}}{bool} %res no me sirve para nada...lo puedo sacar o siempre tiene que estar aunque lo ponga siempre en true?
  [estr = estr$_0$]
  {$res$ $\wedge$ estr =$_{obs}$ encolar(estr$_0$)}%
  [O(log(n))]
  [Crea un nuevo elemento con los parametros dados y lo agrega a la cola.]
  []

  \InterfazFuncion{Desencolar}{\Inout{estr}{heap}}{$\alpha$}
  [estr = $estr_0 \ \wedge \neg Vacia?(estr)$] 
  {estr =$_{obs}$ desencolar($estr_0$) $\wedge \ res =_{obs} proximo(estr_0)$}%
  [O(log(n))]
  [Devuelve al elemento de mayor prioridad y lo remueve de la cola. La cola no debe estar vac\'ia.]
  []
  
  
\end{Interfaz}
\begin{tad}{\tadNombre{Cola de prioridad alternativa($\alpha$)}}
\tadGeneros{colaPrio($\alpha$)}
\tadExporta{colaPrio($\alpha$), generadores, observadores}
\tadUsa{\tadNombre{Bool, Nat, Tupla}}

\tadAlinearFunciones{desencolar}{nat,$\alpha$,colaPrior($\alpha$)}

\tadObservadores
\tadOperacion{vac\'ia?}{colaPrior($\alpha$)}{bool}{}
\tadOperacion{pr\'oximo}{colaPrior($\alpha$)/c}{tupla($nat, \alpha$)}{$\neg$ vac\'ia?($c$)}
\tadOperacion{desencolar}{colaPrior($\alpha$)/c}{colaPrior($\alpha$)}{$\neg$ vac\'ia?($c$)}

\tadGeneradores
\tadOperacion{vac\'ia}{}{colaPrior($\alpha$)}{}
\tadOperacion{encolar}{nat,$\alpha$,colaPrior($\alpha$)}{colaPrior($\alpha$)}{}

\tadAxiomas[\paratodo{colaPrior($\alpha$)}{c}, \paratodo{$\alpha$}{e}]
\tadAlinearAxiomas{desencolar(encolar($p$, $e$, $c$))}{}

\tadAxioma{vac\'ia?(vac\'ia)}{true}
\tadAxioma{vac\'ia?(encolar($p$, $e$, $c$))}{false}

\tadAxioma{pr\'oximo(encolar($p$, $e$, $c$))}{\textbf{if} vac\'ia?($c$) $\oluego$\ $\Pi_1(proximo(c)) < p$ \textbf{then} $<p,e>$ \textbf{else} \textbf{if} $\Pi_1(proximo(c)) = p$ \textbf{then} $<p,e>  \vee \ proximo(c)$ \textbf{else} $proximo(c)$ \textbf{fi} \textbf{fi}}
\tadAxioma{desencolar(encolar($p$, $e$, $c$))}{\textbf{if} vac\'ia?($c$) $\oluego$\ $\Pi_1(proximo(c)) < p$ \textbf{then} $c$ \textbf{else} \textbf{if} $\Pi_1(proximo(c)) = p$ \textbf{then} $c\  \vee \ encolar(p, e, desencolar(c)$ \textbf{else}  $encolar(p, e, desencolar(c)$ \textbf{fi} \textbf{fi}}

\end{tad}

\newpage

\begin{Representacion}

\begin{Estructura}{heap}[estr]

\begin{Tupla}[estr]
	\tupItem{size}{nat} \newline \nomoreitems
	\tupItem{primero}{nodo($\alpha$)} \newline \nomoreitems
\end{Tupla}

\begin{Tupla}[nodo($\alpha$)]
	\tupItem{padre}{puntero(nodo($\alpha$))} \newline \nomoreitems
	\tupItem{izq}{puntero(nodo($\alpha$))} \newline \nomoreitems
	\tupItem{der}{puntero(nodo($\alpha$))} \newline \nomoreitems
	\tupItem{prio}{nat} \newline \nomoreitems
	\tupItem{valor}{$\alpha$} \newline \nomoreitems
\end{Tupla} 

\end{Estructura}

Rep: estr $\rightarrow$ bool
\newline \indent Rep($e$) $\equiv$ true $\iff \ size = \# arbol(estr.primero) \ \wedge_L
\newline \indent ((estr.primero).padre = null \wedge
\newline \indent (\forall e: estr)( e \in arbol(estr.primero) \wedge \ e \neq (estr.primero) \Rightarrow (e.padre \neq null \wedge_L (((e.padre).izq = e \vee (e.padre).der = e ) \wedge \
\neg(((e.padre).izq = e \wedge (e.padre).der = e ))))) \wedge
\newline \indent (\forall e: estr)( e \in arbol(estr.primero) \Rightarrow ((estr.izq \neq null \Rightarrow estr.prio \geq (estr.izq).prio) \wedge (estr.der \neq null \Rightarrow estr.prio \geq (estr.der).prio))) \wedge
\newline \indent (\forall e: estr)( e \in arbol(estr.primero) \Rightarrow caminoHastaRaiz(e,arbol(estr.primero)) \leq \left \lfloor{log_2(size)}\right \rfloor + 1))$

Abs: estr $e \rightarrow$ colaPrio($\alpha$) \{ Rep($e$) \}
Abs($e$) $\equiv$ c: colaPrio($\alpha$) | $Vacia?(e) = Vacia?(c) \ \wedge_L
\newline \indent (\neg Vacia?(e) \Rightarrow Proximo(e) = Proximo(c)) \ \wedge
\newline \indent (\neg Vacia?(e) \Rightarrow Desencolar(e) = Desencolar(c))$

\textbf{Especificaci\'on de las operaciones auxiliares utilizadas para Rep y Abs}
\tadOperacion{arbol}{nodo($\alpha$)}{conj(nodo($\alpha$))}{}
\tadOperacion{caminoHastaRaiz}{nodo($\alpha$)}{nat}{}
\tadAxioma{arbol(n)}{\textbf{if} $n.izq \neq null \wedge n.der \neq null$ \textbf{then} Ag($n.valor,arbol(n.izq)\cup arbol(n.der)$) \textbf{else}
\textbf{if} $n.izq \neq null$ \textbf{then} Ag($n.valor,arbol(n.izq)$) \textbf{else} \textbf{if} $n.der \neq null$ \textbf{then} Ag($n.valor,arbol(n.der)$) \textbf{else} Ag($n.valor,\emptyset$)}
\tadAxioma{caminoHastaRaiz(n)}{\textbf{if} $n.padre = null$ \textbf{then} $0$ \textbf{else} $caminoHastaRaiz(n.padre)+1$}

\end{Representacion}

\begin{Algoritmos}

\begin{algorithm}
\caption{Implementaci\'on de Vacia}
\begin{algorithmic}[0]
\Function{iVacia}{}{$\rightarrow res$: heap}
\State $res\gets $ <$0, null$> \Comment{O(1)}
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Implementaci\'on de Vacia?}
\begin{algorithmic}[0]
\Function{iVacia?}{\In{estr}{heap}}{$\rightarrow res$: bool}
\State $res\gets \ (estr.primero == null)$ \Comment{O(1)}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Implementaci\'on de Primero}
\begin{algorithmic}[0]
\Function{iPrimero}{\In{estr}{heap}}{$\rightarrow res$: tupla($nat, \alpha$)}
\State $res\gets \ <(estr.primero).prioridad, (estr.primero).valor>$ \Comment{O(1)}
\EndFunction
\end{algorithmic}
\end{algorithm}



\begin{algorithm}
\caption{Implementaci\'on de Encolar}
\begin{algorithmic}[0]
\Function{iEncolar}{\Inout{estr}{heap}, \In{prio}{nat}, \In{valor}{$\alpha$}}{$\rightarrow res$: bool}
	\State $res\gets $ $true$	 \Comment{O(1)}
	\If{estr.size == 0} \Comment{O(1)}
		\State $estr.primero\gets$ <$null, null, null, prio, valor$> \Comment{O(1)}
	\Else
		\State $size++$ \Comment{O(1)}
		\State $x\gets \ valor$ \Comment{O(1)}
		\State $y\gets$ <> \Comment{O(1)}
		\While{x $\neq$ 0} \Comment{La cantidad de veces que se ejecuta el ciclo es igual a la altura del heap. Al ser un arbol binario completo, la altura siempre ser\'a O(log(n))}
			\State $y\gets$ $(x \% 2) \bullet y$ \Comment{O(1)}
			\State $x\gets$ $x / 2$ \Comment{O(1)}
		\EndWhile
		\State $y\gets$ com($y$) \Comment{O(log(n))}
		\State $z\gets$ $estr.primero$ \Comment{O(1)}
		\State $y\gets$ fin($y$) \Comment{O(1)}
		\While{long($y$)$>1$} \Comment{El ciclo se ejecuta O(log(n)) veces}
			\State $z\gets$ \textbf{if} prim($y$) $==$ 0 \textbf{then} $z.izq$ \textbf{else} $z.der$ \Comment{O(1)}
			\State $y\gets$ fin($y$) \Comment{O(1)}
		\EndWhile
		\State $w\gets$ <$null,null,null,prio,valor$> \Comment{O(1)}
		\State $w.padre\gets$ $z$ \Comment{O(1)}
		\If{prim($y$) $==$ 0} \Comment{O(1)}
			\State $z.izq\gets \ w$ \Comment{O(1)}
		\Else
			\State $z.der\gets \ w$ \Comment{O(1)}
		\EndIf
		\While{w $\neq \ estr.primero \ \wedge_L \ w.prio >(w.padre).prio$} \Comment{La cantidad de veces que se ejecuta el ciclo es a lo sumo la altura del heap, que es O(log(n))}
			\State $aux\gets \ w.valor$ \Comment{O(1)}
			\State $w.valor\gets \ (w.padre).valor$ \Comment{O(1)}
			\State $(w.padre).valor\gets \ aux$ \Comment{O(1)}
			\State $w\gets \ w.padre$ \Comment{O(1)}
		\EndWhile
	\EndIf

\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Implementaci\'on de Desencolar}
\begin{algorithmic}[0]
\Function{iDesencolar}{\Inout{estr}{heap}}{$\rightarrow res$: $\alpha$}
	\State $res\gets \ estr.primero$ \Comment{O(1)}
	\State $x\gets \ valor$ \Comment{O(1)}
	\State $y\gets \ $ <> \Comment{O(1)}
	\While{x $\neq$ 0} \Comment{La cantidad de veces que se ejecuta el ciclo es igual a la altura del heap. Al ser un arbol binario completo, la altura siempre ser\'a O(log(n))}
		\State $y\gets$ $(x \% 2) \bullet y$ \Comment{O(1)}
		\State $x\gets$ $x / 2$ \Comment{O(1)}
	\EndWhile
	\State $y\gets$ com($y$) \Comment{O(log(n))}
	\State $z\gets$ $estr.primero$ \Comment{O(1)}
	\State $y\gets$ fin($y$) \Comment{O(1)}
	\While{long($y$)$>1$} \Comment{El ciclo se ejecuta O(log(n)) veces}
		\State $z\gets$ \textbf{if} prim($y$) $==$ 0 \textbf{then} $z.izq$ \textbf{else} $z.der$ \Comment{O(1)}
		\State $y\gets$ fin($y$) \Comment{O(1)}
	\EndWhile
	\State $w\gets$ <$null,null,null,prio,valor$> \Comment{O(1)}
	\State $w.padre\gets$ $z$ \Comment{O(1)}
	\If{prim($y$) $==$ 0} \Comment{O(1)}
		\State $z.izq\gets \ w$ \Comment{O(1)}
	\Else
		\State $z.der\gets \ w$ \Comment{O(1)}
	\EndIf
	\State $(estr.primero).valor\gets \ z.valor$ \Comment{O(1)}
	\State borrar($z$) \Comment{O(1)}
	\State $size--$ \Comment{O(1)}
	\While{$(z.izq \neq null \ \vee z.der \neq null) \ \wedge_L \ z.valor < \ maxValor(z.izq, z.der)$} \Comment{La cantidad de veces que se ejecuta el ciclo es a lo sumo la altura del heap, que es O(log(n))}

	\State \Comment{maxValor devuelve el maximo valor si ambos punteros son validos, o el valor apuntado por
	el puntero no nulo en caso de que alguno no lo sea}
	\If{$z.der == null \ \vee_L \ (z.izq).valor \geq (z.der).valor$} \Comment{O(1)}
		\State $aux\gets \ z.valor$ \Comment{O(1)}
		\State $z.valor\gets \ (z.izq).valor$ \Comment{O(1)}
		\State $(z.izq).valor\gets \ aux$ \Comment{O(1)}
		\State $z\gets z.izq$ \Comment{O(1)}
	\Else
		\State $aux\gets \ z.valor$ \Comment{O(1)}
		\State $z.valor\gets \ (z.der).valor$ \Comment{O(1)}
		\State $(z.der).valor\gets \ aux$ \Comment{O(1)}
		\State $z\gets z.der$ \Comment{O(1)}
	\EndIf
	\EndWhile


\EndFunction
\end{algorithmic}
\end{algorithm}

\FloatBarrier
\end{Algoritmos}


