\begin{Interfaz}
  
  \textbf{usa}: \tadNombre{Bool, Nat}.
  
  \textbf{se explica con}: \tadNombre{Diccionario($\kappa, \sigma$)}.

  \textbf{g\'eneros}: \TipoVariable{diccLog($\kappa, \sigma$)}.

  \Titulos{Operaciones}

  \InterfazFuncion{Definido?}{\In{d}{diccLog($\kappa, \sigma$)}, \In{c}{$\kappa$}}{Bool}
  {res $\igobs$ def?(c,d)}%
  [$O(log(n) * comparar(\kappa))$]

  \InterfazFuncion{Significado}{\In{d}{diccLog($\kappa, \sigma$)}, \In{c}{$\kappa$}}{$\sigma$}
  [def?(c,d)]
  {res $\igobs$ obtener(c,d)}%
  [$O(log(n) * comparar(\kappa) + copiar(\sigma)$]
  
  \InterfazFuncion{Vacio}{}{diccLog($\kappa, \sigma$)}
  {res $\igobs$ vacio()}%
  [$O(1)$]
  
  \InterfazFuncion{Definir}{\Inout{d}{diccLog($\kappa, \sigma$)}, \In{c}{$\kappa$}, \In{s}{$\sigma$}}{}
  [$\neg$def?(c,d) $\wedge$ d=d$_0$]
  {d=definir(c,d$_0$)}%
  [O(log(n))]
  
  \InterfazFuncion{Borrar}{\Inout{d}{diccLog($\kappa, \sigma$)}, \In{c}{$\kappa$}}{}
  [def?(c,d) $\wedge$ d=d$_0$]
  {d=borrar(c,d$_0$)}%
  [$O(log(n) * comparar(\kappa) + max(borrar(\kappa), borrar(\sigma)) + max(copiar(\kappa), copiar(\sigma)))$]

\end{Interfaz}

\newpage 

\begin{Representacion}

\begin{Estructura}{diccLog}[puntero(estr($\kappa, \sigma$)]
   
\begin{Tupla}[estr($\kappa, \sigma$)]
\tupItem{clave}{\TipoVariable{$\kappa$}} \newline \nomoreitems{}
\tupItem{izquierdo}{\TipoVariable{puntero(nodo($\kappa,\sigma$))}} \newline \nomoreitems{}	 
\tupItem{derecho}{\TipoVariable{puntero(nodo($\kappa,\sigma$))}} \newline \nomoreitems{}
\tupItem{significado}{\TipoVariable{$\sigma$}} \newline \nomoreitems{}
\tupItem{nivel}{\TipoVariable{nat}}
\end{Tupla}
\newline \comentario{La estructura utilizada para representar al diccionario Logaritmico es un AA tree. Es un tipo de ABB auto-balanceado que provee busqueda, insercion y borrado
en tiempo logaritmico. Los AA trees son similares a los Red-Black Trees, pero solo pueden tener hijos derechos ``rojos'' (en vez de utilizar un valor booleano de color, usan un valor entero de nivel;
los hijos ``rojos'' son los que tienen mismo nivel que sus padres), lo que reduce considerablemente la cantidad de operaciones necesarias para mantener el arbol.}
\newline \comentario{http://user.it.uu.se/$\sim$arnea/abs/simp.html}
% http://user.it.uu.se/~arnea/abs/simp.html
   
\end{Estructura}

Rep: estr $\rightarrow$ bool
$\ $\newline
\newline \indent Rep($e$) $\equiv$ true $\iff$ (($\forall n_1, n_2:\ estr(\kappa, \sigma))(\ n_1 \in\ arbol(e) \wedge \ n_2 \in\ arbol(e) \Rightarrow_L\
\newline \indent (n_1.clave < n_2.clave \Rightarrow n_1 \in arbol(n_2.izquierdo)) \wedge\ (n_1.clave > n_2.clave \Rightarrow n_1 \in arbol(n_2.derecho)) \wedge\ 
\newline \indent ((\forall n_1, n_2:\ estr(\kappa, \sigma))(\ n_1 \in\ arbol(e) \wedge \ n_2 \in\ arbol(e) \wedge\ n_1.clave\neq n_2.clave \Rightarrow_L\
\newline \indent (n_1.izquierdo = n_2.izquierdo \vee n_1.izquierdo = n_2.derecho \Rightarrow n_1.izquierdo = NULO) \wedge\ 
\newline \indent (n_1.derecho = n_2.izquierdo \vee n_1.derecho = n_2.derecho \Rightarrow n_1.derecho = NULO)) \wedge\ 
\newline \indent ((\forall n:\ estr(\kappa, \sigma))(\ n \in\ arbol(e) \wedge n.izquierdo = NULO \wedge n.derecho = NULO \Rightarrow\ n.nivel = 1) \wedge
\newline \indent ((\forall n:\ estr(\kappa, \sigma))(\ n \in\ arbol(e) \wedge n.izquierdo \neq NULO \Rightarrow\ (n.izquierdo).nivel = n.nivel-1) \wedge
\newline \indent ((\forall n:\ estr(\kappa, \sigma))(\ n \in\ arbol(e) \wedge n.derecho \neq NULO \Rightarrow
\newline \indent ((n.derecho).nivel = n.nivel-1 \vee\ (n.derecho).nivel = n.nivel)) \wedge
\newline \indent ((\forall n:\ estr(\kappa, \sigma))(\ n \in\ arbol(e) \wedge n.derecho \neq NULO \wedge_L (n.derecho).derecho \neq NULO \Rightarrow_L
\newline \indent ((n.derecho).derecho).nivel < n.nivel) \wedge
\newline \indent ((\forall n:\ estr(\kappa, \sigma))(\ n \in\ arbol(e) \wedge n.nivel > 1 \Rightarrow\ (n.izquierdo \neq NULO \wedge n.derecho \neq NULO)$
$\ $\newline$\ $
\newline \indent Abs: $diccLog(\kappa, \sigma)\ d \rightarrow\ dicc(\kappa, \sigma)$ \{Rep($d$) \}
$\ $\newline
$\ $\newline \indent Abs($d$) $\equiv$ c: dicc($\kappa, \sigma$) | $((\forall k:\ \kappa)(\ k \in claves(c) \Rightarrow (\exists n:\ estr(\kappa, \sigma))( n \in arbol(d)\wedge n.clave = k)) \wedge
\newline \indent ((\forall n:\ estr(\kappa, \sigma))( n \in arbol(d) \Rightarrow\ n.clave \in claves(c)))) \wedge_L
\newline \indent (\forall n:\ estr(\kappa, \sigma))( n \in arbol(d) \Rightarrow\ obtener(c,n.clave) =_{obs} n.significado)$

$\ $\newline$\ $
\newline \indent \textbf{Especificaci\'on de las operaciones auxiliares utilizadas para Rep y Abs}
\newline \indent arbol:$\ puntero(estr(\kappa\, \sigma)) \rightarrow conj(puntero(\kappa,\sigma))$


\tadAxioma{arbol(n)}{
\IF {$n.izq \neq null \wedge n.der \neq null$}
THEN {Ag($\&n,arbol(n.izq)\cup arbol(n.der)$)}
ELSE { \IF {$n.izq \neq null$}
		THEN {Ag($\&n,arbol(n.izq)$)}
		ELSE { \LIF\ $n.der \neq null$ \LTHEN\ Ag($\&n,arbol(n.der)$) \LELSE\ Ag($\&n,\emptyset$) \LFI}
		FI}
FI}

\end{Representacion}

\newpage

\begin{Algoritmos}

\begin{algorithm}
\caption{Implementaci\'on de Definido?}
\begin{algorithmic}[0]
\Function{iDefinido?}{in d: estr , in c: $\kappa$}{$\rightarrow$ res: bool}
	\comentario{B\'usqueda est\'andar en un ABB}
	\State nodoActual $\gets$ d \Comment{O(1)}
	\State res $\gets$ FALSE \Comment{O(1)}
	\While{$\neg$(nodoActual == NULO) $\&\&$ $\neg$res} \Comment{El ciclo se ejecuta en el peor caso una cantidad de veces igual a la altura del arbol. Al ser auto-balanceado, su altura siempre sera O(log(n))}
		\If{nodoActual.clave == c} \Comment{O(comparar($\kappa$))}
			\State res $\gets$ TRUE \Comment{O(1)}
		\Else
			\If{c < nodoActual.clave} \Comment{O(comparar($\kappa$))}
				\State nodoActual $\gets$ nodoActual.izquierdo \Comment{O(1)}
			\Else
				\State nodoActual $\gets$ nodoActual.derecho \Comment{O(1)}
			\EndIf
		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Implementaci\'on de Significado}
\begin{algorithmic}[0]
\Function{iSignificado}{in d: estr , in c: $\kappa$}{$\rightarrow$ res: $\sigma$}
	\comentario{B\'usqueda est\'andar en un ABB}
	\State nodoActual $\gets$ d \Comment{O(1)}
	\While{$\neg$(nodoActual == NULO) $\&\&$ $\neg$res} \Comment{El ciclo se ejecuta en el peor caso O(log(n)) veces.}
		\If{nodoActual.clave == c} \Comment{O(comparar($\kappa$))}
			\State res $\gets$ nodoActual.significado \Comment{O(copiar($\sigma$)). Esta operacion solo se ejecuta una vez (implica $\neg$guarda del ciclo que la contiene).}
		\Else
			\If{c < nodoActual.clave} \Comment{O(comparar($\kappa$))}
				\State nodoActual $\gets$ nodoActual.izquierdo \Comment{O(1)}
			\Else
				\State nodoActual $\gets$ nodoActual.derecho \Comment{O(1)}
			\EndIf
		\EndIf
	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Implementaci\'on de Vacio}
\begin{algorithmic}[0]
\Function{iVacio}{}{$\rightarrow$ res: estr}
	\State res $\gets$ NULO \Comment{O(1)}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Implementaci\'on de Definir}
\begin{algorithmic}[0]
\Function{iDefinir}{inout d: estr , in c: $\kappa$, in s: $\sigma$}{}
	\comentario{Si ya se llego a una hoja, se inserta el nuevo elemento}
	\If{d == NULO} \Comment{O(1)}
		\State $res\gets \ <c, NULO, NULO, s, 1>$ \Comment{O(max(copiar($\kappa$), copiar($\sigma$))}
	\comentario{Se busca la posicion correspondiente al nuevo nodo (antes de rebalancear el arbol).}
	\ElsIf{$c < d.clave$} \Comment{O(comparar($\kappa$)}
		\State $d.izquierdo\gets \ iDefinir(d.izquierdo,c,s)$ \Comment{En el peor caso se llama recursivamente a la funcion una cantidad de veces igual a la altura
		del arbol, que es O(log(n)).}
	\ElsIf{$c > d.clave$} \Comment{O(comparar($\kappa$))}
		\State $d.derecho\gets \ iDefinir(d.derecho,c,s)$ \Comment{En el peor caso se llama recursivamente a la funcion una cantidad de veces igual a la altura
		del arbol, que es O(log(n)).}
	\EndIf
	\comentario{Se tuerce y divide el arbol en cada nivel, rebalanceandolo.}
	\State $d \gets\ Torsion(d)$ \Comment{O(1)}
	\State $d \gets\ Division(d)$ \Comment{O(1)}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Implementaci\'on de Torsion}
\begin{algorithmic}[0]
\Function{iTorsion}{in d: estr}{$\rightarrow$ res: estr}
	\comentario{Si el nodo tiene un hijo izquierdo del mismo nivel se debe realizar una rotacion para restaurar el invariante.}
	\If{d == NULO $\|$ d.izquierdo == NULO} \Comment{O(1)}
		\State res $\gets$ d \Comment{O(1)}
	\Else
	\comentario{El hijo izquierdo de mismo nivel pasa a ser el padre del nodo derecho. El hijo derecho del nodo izquierdo pasa a ser el hijo izquierdo del nodo derecho.}
		\If{(d.izquierdo).nivel == d.nivel} \Comment{O(1)}
			\State nodoAux $\gets$ d.izquierdo \Comment{O(1)}
			\State d.izquierdo $\gets$ nodoAux.derecho \Comment{O(1)}
			\State nodo.derecho $\gets$ d \Comment{O(1)}
			\State res $\gets$ nodoAux \Comment{O(1)}
		\Else
			\State res $\gets$ d \Comment{O(1)}
		\EndIf
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Implementaci\'on de Division}
\begin{algorithmic}[0]
\Function{iDivision}{in d: estr}{$\rightarrow$ res: estr}
	\comentario{Si hay dos hijos derechos del mismo nivel que el padre se debe realizar una rotacion para restaurar el invariante.}
	\If{d == NULO $\|$ d.derecho == NULO $\|$ d.derecho.derecho == NULO} \Comment{O(1)}
		\State res $\gets$ d \Comment{O(1)}
	\Else
	\comentario{El primero hijo derecho pasa a ser el padre, con un nivel mas. Su hijo izquierdo pasa a ser el hijo derecho de su padre original.}
		\If{(d.derecho.derecho).nivel == d.nivel} \Comment{O(1)}
			\State nodoAux $\gets$ d.derecho \Comment{O(1)}
			\State d.derecho $\gets$ nodoAux.izquierdo \Comment{O(1)}
			\State nodoAux.izquierdo $\gets$ d \Comment{O(1)}
			\State nodoAux.nivel$++$ \Comment{O(1)}
			\State res $\gets$ nodoAux \Comment{O(1)}
		\Else
			\State res $\gets$ d \Comment{O(1)}
		\EndIf
	\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\FloatBarrier
\end{Algoritmos}

\begin{algorithm}
\caption{Implementaci\'on de Borrar}
\begin{algorithmic}[0]
\Function{iBorrar}{inout d: estr, in c: $\kappa$}{}
	\If{$d == NULO$} \Comment{O(1)}
		\State $endFunction$
	\comentario{Se busca recursivamente la posicion del elemento a borrar mediante una busqueda estandar en ABB.}
	\ElsIf{$c > d.clave$} \Comment{O(comparar($\kappa$))}
		\State $d.derecho\gets \ iBorrar(d.derecho, c)$ \Comment{En el peor caso se llama recursivamente a la funcion una cantidad de veces igual a la altura
		del arbol, que es O(log(n)).}
	\ElsIf{$c < d.clave$} \Comment{O(comparar($\kappa$))}
		\State $d.izquierdo\gets \ iBorrar(d.izquierdo, c)$ \Comment{En el peor caso se llama recursivamente a la funcion una cantidad de veces igual a la altura
		del arbol, que es O(log(n)).}
	\comentario{Si el elemento a borrar es una hoja, simplemente se lo borra.}
	\ElsIf{$d.izquierdo == NULO \wedge\ d.derecho == NULO$} \Comment{O(1)}
		\State $borrar(d)$ \Comment{O(max(borrar($\kappa$), borrar($\sigma$)))}
		\State $d\gets\ NULO$ \Comment{O(1)}
	\comentario{Si el elemento a borrar no es una hoja, se reduce al caso hoja.}
	\ElsIf{$d.izquierdo == NULO$} \Comment{O(1)}
	\comentario{Se busca el sucesor del elemento (bajando una vez por la rama izquierda y luego por la derecha hasta encontrar una hoja).}
		\State $aux\gets\ d.derecho$ \Comment{O(1)}
		\While{$aux.izquierdo \neq NULO$} \Comment{En el peor caso el ciclo se ejecuta O(log(n)) veces.}
			\State $aux\gets\ aux.izquierdo$ \Comment{O(1)}
		\EndWhile
		\comentario{Se hace un swap y se elimina el elemento.}
		\State $d.derecho\gets\ iBorrar(aux.clave, d.derecho)$
		\State $d.clave\gets\ aux.clave$ \Comment{O(copiar($\kappa$))}
		\State $d.significado\gets\ aux.significado$ \Comment{O(copiar($\sigma$))}
	\Else
	\comentario{Se busca el predecesor del elemento (bajando una vez por la rama derecha y luego por la izquierda hasta encontrar una hoja).}
		\State $aux\gets\ d.izquierdo$ \Comment{O(1)}
		\While{$aux.derecho \neq NULO$} \Comment{En el peor caso el ciclo se ejecuta O(log(n)) veces.}
			\State $aux\gets\ aux.derecho$ \Comment{O(1)}
		\EndWhile
		\comentario{Se hace un swap y se elimina el elemento.}
		\State $d.izquierdo\gets\ iBorrar(aux.clave, d.izquierdo)$
		\State $d.clave\gets\ aux.clave$ \Comment{O(copiar($\kappa$))}
		\State $d.significado\gets\ aux.significado$ \Comment{O(copiar($\sigma$))}
	\EndIf
	\comentario{Se nivela, divide y tuerce para restaurar el invariante.}
	\State $d\gets\ Nivelar(T)$ \Comment{O(1)}
	\State $d\gets\ Torsion(T)$ \Comment{O(1)}
	\If{$d.derecho \neq NULO$} \Comment{O(1)}
		\State $(d.derecho).derecho\gets\ Torsion((d.derecho).derecho)$ \Comment{O(1)}
	\EndIf
	\State $d\gets\ Division(T)$ \Comment{O(1)}
	\State $d.derecho\gets\ Division(d.derecho)$ \Comment{O(1)}
	\State $res\gets\ d$ \Comment{O(1)}
\EndFunction
\Procedure{Nivelar}{inout d: estr}{}
	\State $nivel\_correcto\gets\ min((d.izquierdo).nivel, (d.derecho).nivel)+1$ \Comment{O(1)}
	\If{$nivel\_correcto < d.nivel$} \Comment{O(1)}
		\State $d.nivel\gets\ nivel\_correcto$	 \Comment{O(1)}
		\If{$nivel\_correcto < (d.derecho).nivel$} \Comment{O(1)}
			\State $(d.derecho)nivel\gets\ nivel\_correcto$ \Comment{O(1)}
		\EndIf
	\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}


